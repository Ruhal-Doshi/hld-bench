import fs from "node:fs";
import path from "node:path";
import type { HLDOutput, RunMeta } from "../types.js";
import { log } from "../utils/logger.js";
import { sanitizeMermaid } from "./writer.js";

/**
 * Regenerate .mmd and design.md files from raw-response.json + meta.json.
 *
 * This is useful when:
 * - The normalization logic has been updated
 * - .mmd or .md files were corrupted or deleted
 * - You want to refresh derived files without re-running the LLM
 */
export function regenerateOutputs(outputDir: string): number {
  if (!fs.existsSync(outputDir)) {
    log.error(`Output directory not found: ${outputDir}`);
    return 0;
  }

  const dirs = fs.readdirSync(outputDir, { withFileTypes: true }).filter((d) => d.isDirectory());
  let regenerated = 0;

  for (const dir of dirs) {
    const runDir = path.join(outputDir, dir.name);
    const metaPath = path.join(runDir, "meta.json");
    const rawPath = path.join(runDir, "raw-response.json");

    if (!fs.existsSync(metaPath) || !fs.existsSync(rawPath)) continue;

    try {
      const meta: RunMeta = JSON.parse(fs.readFileSync(metaPath, "utf-8"));
      const output: HLDOutput = JSON.parse(fs.readFileSync(rawPath, "utf-8"));

      // Regenerate .mmd files
      if (output.architectureDiagram) {
        fs.writeFileSync(path.join(runDir, "architecture.mmd"), sanitizeMermaid(output.architectureDiagram));
      }
      if (output.dataFlow) {
        fs.writeFileSync(path.join(runDir, "data-flow.mmd"), sanitizeMermaid(output.dataFlow));
      }

      // Regenerate design.md
      const markdown = renderDesignMarkdown(output, meta);
      fs.writeFileSync(path.join(runDir, "design.md"), markdown);

      regenerated++;
      log.dim(`  Regenerated: ${dir.name}`);
    } catch (err) {
      log.warn(`Skipping ${dir.name}: ${err instanceof Error ? err.message : String(err)}`);
    }
  }

  return regenerated;
}

/**
 * Render the structured HLD output into a readable Markdown document.
 * (Duplicated from writer.ts to keep regenerate self-contained and avoid
 * circular dependency issues; could be extracted to a shared module later.)
 */
function renderDesignMarkdown(output: HLDOutput, meta: RunMeta): string {
  const lines: string[] = [];

  lines.push(`# ${output.title}`);
  lines.push("");
  lines.push(`> Generated by **${meta.model}** (${meta.provider}) on ${meta.timestamp}`);
  lines.push(`> Duration: ${meta.durationMs}ms`);
  lines.push("");

  lines.push("## Overview");
  lines.push("");
  lines.push(output.overview);
  lines.push("");

  lines.push("## Requirements");
  lines.push("");
  lines.push("### Functional");
  for (const req of output.requirements.functional) {
    lines.push(`- ${req}`);
  }
  lines.push("");
  lines.push("### Non-Functional");
  for (const req of output.requirements.nonFunctional) {
    lines.push(`- ${req}`);
  }
  lines.push("");

  lines.push("## Architecture Diagram");
  lines.push("");
  lines.push("```mermaid");
  lines.push(sanitizeMermaid(output.architectureDiagram));
  lines.push("```");
  lines.push("");

  lines.push("## Components");
  lines.push("");
  for (const comp of output.components) {
    lines.push(`### ${comp.name}`);
    lines.push("");
    lines.push(`- **Responsibility:** ${comp.responsibility}`);
    lines.push(`- **Technology:** ${comp.techChoice}`);
    lines.push(`- **Justification:** ${comp.justification}`);
    lines.push("");
  }

  lines.push("## Data Flow");
  lines.push("");
  lines.push("```mermaid");
  lines.push(sanitizeMermaid(output.dataFlow));
  lines.push("```");
  lines.push("");

  lines.push("## Data Storage");
  lines.push("");
  lines.push("| Store | Type | Justification |");
  lines.push("|-------|------|---------------|");
  for (const store of output.dataStorage) {
    lines.push(`| ${store.store} | ${store.type} | ${store.justification} |`);
  }
  lines.push("");

  lines.push("## API Design");
  lines.push("");
  lines.push("| Method | Endpoint | Description |");
  lines.push("|--------|----------|-------------|");
  for (const api of output.apiDesign) {
    lines.push(`| ${api.method} | \`${api.endpoint}\` | ${api.description} |`);
  }
  lines.push("");

  lines.push("## Scalability Strategy");
  lines.push("");
  lines.push(output.scalabilityStrategy);
  lines.push("");

  lines.push("## Trade-offs");
  lines.push("");
  for (const tradeoff of output.tradeoffs) {
    lines.push(`### ${tradeoff.decision}`);
    lines.push("");
    lines.push("**Pros:**");
    for (const pro of tradeoff.pros) {
      lines.push(`- ${pro}`);
    }
    lines.push("");
    lines.push("**Cons:**");
    for (const con of tradeoff.cons) {
      lines.push(`- ${con}`);
    }
    lines.push("");
  }

  return lines.join("\n");
}
